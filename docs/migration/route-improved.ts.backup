// 개선된 inspection sessions API
// 주요 개선사항:
// 1. 트랜잭션 내에서 assignment 업데이트 (데이터 정합성 보장)
// 2. 중복 세션 방지 로직 추가
// 3. 롤백 시나리오 고려

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { LRUCache } from 'lru-cache';
import { canPerformInspection, AccessContext } from '@/lib/session-permissions';
import { analyzeInspectionFields } from '@/app/api/inspections/utils/field-analyzer';
import logger from '@/lib/logger';
import { prisma } from '@/lib/prisma';

// 중복 갱신 방지용 메모리 캐시 (기존 코드 유지)
const refreshingSessionsCache = new LRUCache<string, boolean>({
  max: 1000,
  ttl: 1000 * 60 * 5, // 5분
});

const refreshStartTimes = new LRUCache<string, number>({
  max: 1000,
  ttl: 1000 * 60 * 10, // 10분
});

// 타입 정의
interface SessionPayload {
  equipment_serial?: string;
  sessionId?: string;
  currentStep?: number;
  status?: 'active' | 'paused' | 'completed' | 'cancelled';
  stepData?: Record<string, unknown>;
  finalizeData?: Record<string, unknown>;
  notes?: string;
}

// 인증 및 권한 확인 함수
async function requireAuthWithRole() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    throw new Error('Unauthorized');
  }

  const profile = await prisma.user_profiles.findUnique({
    where: { id: session.user.id },
    select: {
      id: true,
      role: true,
      assigned_devices: true,
      organization_id: true
    }
  });

  if (!profile) {
    throw new Error('User profile not found');
  }

  const accessContext: AccessContext = {
    userId: profile.id,
    role: profile.role,
    accountType: 'public',
    assignedDevices: profile.assigned_devices || [],
    organizationId: profile.organization_id || undefined,
  };

  if (!canPerformInspection(accessContext)) {
    throw new Error('Inspection not permitted for this user');
  }

  return { userId: session.user.id, profile, accessContext } as const;
}

// 스냅샷 갱신 필요 여부 판단
function shouldRefreshSnapshot(session: any): boolean {
  const now = new Date();
  const lastUpdate = new Date(session.updated_at || session.started_at);
  const hoursSinceUpdate = (now.getTime() - lastUpdate.getTime()) / (1000 * 60 * 60);

  // 점검 진행 중이면 갱신 안함
  if (session.status === 'active' && session.current_step > 0) {
    return false;
  }

  // 최근 1시간 이내 갱신했으면 스킵
  if (hoursSinceUpdate < 1) {
    return false;
  }

  // 12시간 경과 시 갱신
  if (hoursSinceUpdate >= 12) {
    return true;
  }

  return false;
}

// 백그라운드 스냅샷 갱신
async function refreshSnapshotInBackground(sessionId: string, equipment_serial: string) {
  try {
    const device = await prisma.aed_data.findUnique({
      where: { equipment_serial }
    });

    if (device) {
      await prisma.inspection_sessions.update({
        where: { id: sessionId },
        data: {
          device_info: device as any,
          updated_at: new Date()
        }
      });
      logger.info('InspectionSession:refreshSnapshot', 'Snapshot refreshed', { sessionId });
    }
  } catch (error) {
    logger.error('InspectionSession:refreshSnapshot', 'Failed to refresh snapshot', error);
    throw error;
  }
}

function mergeStepData(
  existingData: Record<string, unknown>,
  newData: Record<string, unknown> | undefined
): Record<string, unknown> {
  if (!newData) return existingData;

  const merged = { ...existingData };

  for (const [key, value] of Object.entries(newData)) {
    if (value !== undefined) {
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        merged[key] = {
          ...(typeof merged[key] === 'object' && merged[key] !== null ? merged[key] : {}),
          ...value
        };
      } else {
        merged[key] = value;
      }
    }
  }

  return merged;
}

// POST: 신규 세션 생성 또는 기존 세션 업데이트
export const POST = async (request: NextRequest) => {
  const { userId } = await requireAuthWithRole();
  const payload: SessionPayload = await request.json();

  // 신규 세션 생성 요청
  if (payload.equipment_serial && !payload.sessionId) {
    logger.info('InspectionSession:POST', 'Creating new session', {
      equipmentSerial: payload.equipment_serial,
      userId
    });

    // [개선 1] 중복 세션 체크 로직 추가
    // 활성 세션이 이미 있는지 확인
    const existingActiveSession = await prisma.inspection_sessions.findFirst({
      where: {
        equipment_serial: payload.equipment_serial,
        inspector_id: userId,
        status: { in: ['active', 'paused'] }
      },
      select: {
        id: true,
        status: true,
        created_at: true
      }
    });

    // 활성 세션이 있으면 해당 세션 정보 반환
    if (existingActiveSession) {
      logger.info('InspectionSession:POST', 'Existing active session found', {
        sessionId: existingActiveSession.id,
        status: existingActiveSession.status,
        equipmentSerial: payload.equipment_serial
      });

      // 기존 세션 전체 데이터 조회하여 반환
      const fullSession = await prisma.inspection_sessions.findUnique({
        where: { id: existingActiveSession.id }
      });

      return NextResponse.json({
        session: fullSession,
        message: 'Active session already exists',
        reused: true  // 클라이언트에게 재사용되었음을 알림
      });
    }

    // 장비 정보 스냅샷 생성 (기존 로직 유지)
    let deviceSnapshot = {};
    if (payload.equipment_serial) {
      const device = await prisma.aed_data.findUnique({
        where: { equipment_serial: payload.equipment_serial }
      });

      if (device) {
        logger.info('InspectionSession:POST', 'Device data loaded from aed_data', {
          equipmentSerial: payload.equipment_serial
        });
        deviceSnapshot = device as any;
      } else {
        logger.warn('InspectionSession:POST', 'No device found for equipment_serial', {
          equipmentSerial: payload.equipment_serial
        });
      }
    }

    // 신규 세션 생성
    const data = await prisma.inspection_sessions.create({
      data: {
        equipment_serial: payload.equipment_serial,
        inspector_id: userId,
        current_step: 0,
        device_info: deviceSnapshot as any,
        status: 'active'
      }
    });

    return NextResponse.json({
      session: {
        ...data,
        device_info: data.device_info
      }
    });
  }

  // 기존 세션 업데이트
  if (!payload.sessionId) {
    return NextResponse.json(
      { error: 'sessionId is required for update' },
      { status: 400 }
    );
  }

  // 세션 조회 및 권한 확인
  const session = await prisma.inspection_sessions.findUnique({
    where: { id: payload.sessionId },
    select: {
      id: true,
      inspector_id: true,
      equipment_serial: true,
      status: true,
      device_info: true,
      step_data: true
    }
  });

  if (!session) {
    return NextResponse.json({ error: 'Session not found' }, { status: 404 });
  }

  if (session.inspector_id !== userId) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  // 이미 완료된 세션은 수정 불가
  if (session.status === 'completed') {
    return NextResponse.json(
      {
        error: 'Cannot modify completed session',
        details: 'Session is already completed',
      },
      { status: 400 }
    );
  }

  const mergedStepData = mergeStepData(
    (session.step_data as Record<string, unknown> | null) ?? {},
    payload.stepData,
  );

  const updates: any = {
    step_data: mergedStepData,
  };

  if (typeof payload.currentStep === 'number') {
    updates.current_step = payload.currentStep;
  }

  if (payload.status && payload.status !== session.status) {
    updates.status = payload.status;
    if (payload.status === 'paused') {
      updates.paused_at = new Date();
    }
    if (payload.status === 'active') {
      updates.resumed_at = new Date();
    }
    if (payload.status === 'cancelled') {
      updates.cancelled_at = new Date();
    }
  }

  if (payload.notes !== undefined) {
    updates.notes = payload.notes;
  }

  // 점검 완료 처리
  if (payload.status === 'completed' || payload.finalizeData) {
    const finalData = mergeStepData(mergedStepData, payload.finalizeData);

    logger.info('InspectionSession:POST-complete', 'Starting completion process', {
      sessionId: payload.sessionId,
      equipmentSerial: session.equipment_serial
    });

    // [개선 2] 트랜잭션 내에서 모든 관련 업데이트 수행
    try {
      let createdInspectionId: string | null = null;
      let assignmentUpdateCount = 0;

      const completedSession = await prisma.$transaction(async (tx) => {
        // 1. 세션 완료 업데이트
        const updated = await tx.inspection_sessions.update({
          where: { id: payload.sessionId },
          data: {
            status: 'completed',
            completed_at: new Date(),
            step_data: finalData as any,
            updated_at: new Date()
          }
        });

        // 2. inspection 레코드 생성
        const basicInfo = finalData.basicInfo as any || {};
        const deviceInfo = finalData.deviceInfo as any || {};
        const storage = finalData.storage as any || {};

        const createdInspection = await tx.inspections.create({
          data: {
            equipment_serial: session.equipment_serial,
            inspector_id: userId,
            inspection_date: new Date(),
            inspection_type: 'monthly',
            battery_status: deviceInfo.battery_expiry_date_matched === true ? 'good' :
                          (deviceInfo.battery_expiry_date_matched === 'edited' ? 'replaced' : 'not_checked'),
            pad_status: deviceInfo.pad_expiry_date_matched === true ? 'good' :
                       (deviceInfo.pad_expiry_date_matched === 'edited' ? 'replaced' : 'not_checked'),
            overall_status: (finalData.overallStatus as any) || 'pass',
            notes: payload.notes,
            original_data: session.device_info || {},
            inspected_data: {
              basicInfo: basicInfo,
              deviceInfo: deviceInfo,
              storage: storage,
              confirmedLocation: basicInfo.address,
              confirmedManufacturer: deviceInfo.manufacturer,
              confirmedModelName: deviceInfo.model_name,
              confirmedSerialNumber: deviceInfo.serial_number,
              batteryExpiryChecked: deviceInfo.battery_expiry_date,
              padExpiryChecked: deviceInfo.pad_expiry_date
            }
          }
        });

        createdInspectionId = createdInspection.id;

        // 3. aed_data 테이블 업데이트 (에러 시에도 계속 진행)
        try {
          await tx.aed_data.update({
            where: { equipment_serial: session.equipment_serial },
            data: {
              last_inspection_date: new Date()
            }
          });
          logger.info('InspectionSession:POST-complete', 'Updated last_inspection_date', {
            equipmentSerial: session.equipment_serial
          });
        } catch (updateError) {
          // aed_data 없어도 계속 진행 (로그만 남김)
          logger.warn('InspectionSession:POST-complete', 'Failed to update last_inspection_date',
            updateError instanceof Error ? updateError : { updateError }
          );
        }

        // 4. [개선된 부분] assignment 업데이트를 트랜잭션 내부로 이동
        if (session.equipment_serial) {
          try {
            const assignmentResult = await tx.inspection_assignments.updateMany({
              where: {
                equipment_serial: session.equipment_serial,
                assigned_to: userId,
                status: { in: ['pending', 'in_progress'] }
              },
              data: {
                status: 'completed',
                completed_at: new Date()
              }
            });

            assignmentUpdateCount = assignmentResult.count;

            if (assignmentUpdateCount > 0) {
              logger.info('InspectionSession:POST-complete', 'Assignments marked as completed', {
                equipmentSerial: session.equipment_serial,
                updatedCount: assignmentUpdateCount
              });
            }
          } catch (assignmentError) {
            // assignment 업데이트 실패 시 로그 남기지만 트랜잭션은 계속
            // (assignment가 없을 수도 있음 - 즉시점검의 경우)
            logger.warn('InspectionSession:POST-complete', 'Failed to update assignments', {
              equipmentSerial: session.equipment_serial,
              error: assignmentError instanceof Error ? assignmentError.message : 'Unknown error'
            });
          }
        }

        return updated;
      }, {
        // 트랜잭션 옵션: 격리 수준 설정
        isolationLevel: 'ReadCommitted',
        // 타임아웃 설정 (10초)
        timeout: 10000,
        // 재시도 횟수
        maxWait: 5000
      });

      // 필드 비교 분석 (비동기로 실행 - 실패해도 무관)
      if (createdInspectionId && session.equipment_serial) {
        const basicInfo = finalData.basicInfo as any || {};
        const deviceInfo = finalData.deviceInfo as any || {};
        const supplies = finalData.supplies as any || {};

        analyzeInspectionFields(
          createdInspectionId,
          session.equipment_serial,
          {
            basicInfo,
            deviceInfo,
            supplies
          }
        ).catch(error => {
          logger.error('InspectionSession:POST-complete', '필드 비교 분석 실패',
            error instanceof Error ? error : { error }
          );
        });
      }

      logger.info('InspectionSession:POST-complete', 'Completion successful', {
        sessionId: completedSession.id,
        inspectionId: createdInspectionId,
        assignmentsUpdated: assignmentUpdateCount
      });

      return NextResponse.json({
        session: completedSession,
        inspection_id: createdInspectionId,
        assignments_updated: assignmentUpdateCount
      });

    } catch (transactionError: any) {
      // 트랜잭션 실패 시 상세한 에러 로깅
      logger.error('InspectionSession:POST-complete', 'Transaction failed', {
        sessionId: payload.sessionId,
        error: transactionError instanceof Error ? {
          message: transactionError.message,
          stack: transactionError.stack
        } : transactionError
      });

      // 클라이언트에게 명확한 에러 메시지 전달
      return NextResponse.json(
        {
          error: '점검 완료 처리 중 오류가 발생했습니다.',
          details: transactionError.message,
          code: 'TRANSACTION_FAILED'
        },
        { status: 500 }
      );
    }
  }

  // 일반 업데이트 (완료가 아닌 경우)
  const updated = await prisma.inspection_sessions.update({
    where: { id: payload.sessionId },
    data: updates
  });

  return NextResponse.json({ session: updated });
};

// GET: 세션 조회
export const GET = async (request: NextRequest) => {
  const { userId } = await requireAuthWithRole();
  const sessionId = request.nextUrl.searchParams.get('sessionId');
  const status = request.nextUrl.searchParams.get('status');

  if (sessionId) {
    // 단일 세션 조회
    const data = await prisma.inspection_sessions.findUnique({
      where: { id: sessionId }
    });

    if (!data) {
      return NextResponse.json({ error: 'Session not found' }, { status: 404 });
    }

    if (data.inspector_id !== userId) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    // 마지막 접근 시간 업데이트 (비차단)
    prisma.inspection_sessions.update({
      where: { id: sessionId },
      data: { updated_at: new Date() }
    })
      .then(() => logger.info('InspectionSession:GET', 'Last accessed updated', { sessionId }))
      .catch(err => logger.error('InspectionSession:GET', 'Failed to update last_accessed', err));

    // 타임아웃 경고 체크
    const now = new Date();
    const lastAccess = new Date(data.updated_at || data.started_at);
    const hoursSinceAccess = (now.getTime() - lastAccess.getTime()) / (1000 * 60 * 60);

    let warning = null;
    if (hoursSinceAccess > 24 && data.status === 'active') {
      warning = {
        type: 'stale_session',
        message: '24시간 이상 접근하지 않은 세션입니다. 계속 진행하시겠습니까?',
        hoursSinceAccess: Math.floor(hoursSinceAccess),
        suggestAction: 'resume_or_cancel',
        severity: 'high'
      };
    } else if (hoursSinceAccess > 4 && data.status === 'active') {
      warning = {
        type: 'inactive_session',
        message: '4시간 이상 접근하지 않았습니다. 점검을 계속 진행하세요.',
        hoursSinceAccess: Math.floor(hoursSinceAccess),
        severity: 'medium'
      };
    }

    // 갱신 필요 여부 체크
    const needsRefresh = shouldRefreshSnapshot(data);
    const isAlreadyRefreshing = refreshingSessionsCache.has(sessionId);

    // 백그라운드 갱신
    if (needsRefresh && !isAlreadyRefreshing) {
      refreshingSessionsCache.set(sessionId, true);
      refreshStartTimes.set(sessionId, Date.now());

      refreshSnapshotInBackground(sessionId, data.equipment_serial)
        .catch(err => {
          logger.error('InspectionSession:GET', 'Background refresh failed', err);
        })
        .finally(() => {
          refreshingSessionsCache.delete(sessionId);
          refreshStartTimes.delete(sessionId);
        });
    }

    return NextResponse.json({
      session: data,
      refreshing: needsRefresh && !isAlreadyRefreshing,
      warning
    });
  }

  // 세션 목록 조회
  const sessions = await prisma.inspection_sessions.findMany({
    where: {
      inspector_id: userId,
      ...(status ? { status: status as any } : {})
    },
    orderBy: { created_at: 'desc' },
    take: 50
  });

  return NextResponse.json({ sessions });
};

// DELETE: 세션 취소 (데이터 삭제 없이 상태만 변경)
export const DELETE = async (request: NextRequest) => {
  const { userId } = await requireAuthWithRole();
  const sessionId = request.nextUrl.searchParams.get('sessionId');

  if (!sessionId) {
    return NextResponse.json(
      { error: 'sessionId is required' },
      { status: 400 }
    );
  }

  // [개선 3] 트랜잭션으로 세션과 assignment를 함께 업데이트
  try {
    const result = await prisma.$transaction(async (tx) => {
      // 세션 조회
      const session = await tx.inspection_sessions.findUnique({
        where: { id: sessionId },
        select: {
          id: true,
          inspector_id: true,
          equipment_serial: true,
          status: true
        }
      });

      if (!session) {
        throw new Error('Session not found');
      }

      if (session.inspector_id !== userId) {
        throw new Error('Forbidden');
      }

      if (session.status === 'completed') {
        throw new Error('완료된 세션은 취소할 수 없습니다.');
      }

      if (session.status === 'cancelled') {
        throw new Error('이미 취소된 세션입니다.');
      }

      // 세션 취소
      const cancelled = await tx.inspection_sessions.update({
        where: { id: sessionId },
        data: {
          status: 'cancelled',
          cancelled_at: new Date()
        }
      });

      // assignment 상태 업데이트
      if (session.equipment_serial) {
        await tx.inspection_assignments.updateMany({
          where: {
            equipment_serial: session.equipment_serial,
            assigned_to: userId,
            status: 'in_progress'
          },
          data: {
            status: 'pending',
            started_at: null
          }
        });

        logger.info('InspectionSession:DELETE', 'Session and assignments cancelled', {
          sessionId,
          equipmentSerial: session.equipment_serial
        });
      }

      return cancelled;
    });

    return NextResponse.json({
      session: result,
      message: '점검 세션이 취소되었습니다. 모든 데이터는 보관되었습니다.'
    });

  } catch (error: any) {
    logger.error('InspectionSession:DELETE', 'Cancellation failed', error);

    if (error.message === 'Session not found') {
      return NextResponse.json({ error: error.message }, { status: 404 });
    }
    if (error.message === 'Forbidden') {
      return NextResponse.json({ error: error.message }, { status: 403 });
    }
    if (error.message.includes('완료된') || error.message.includes('이미 취소된')) {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return NextResponse.json(
      { error: '세션 취소 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
};